# Projet-LPHYS1351

Chaque code "Solar_flare_selection" possède la même structure : après la déclaration des éruptions, nous affichons la répartition de l'échantillon dans chaque variable considérée en utilisant le code couleur déterminé par les types d'éruptions définis dans Abejo and al (2021).
Ensuite, nous regardons quelques corrélations préliminaires motivées par des remarques à la fin de ce même article, avec un second code couleur se basant sur la provenance d'un certain groupe de régions actives ou de séries d'éruptions solaires identifiées dans cette source. Nous terminons la première partie du code par une matrcice de corrélations entre les variables à l'aide de la fonction scatter_matrix du package pandas.plotting, répétée dans les deux codes couleur, ainsi qu'une troisième fois sans couleurs. 

Dans la partie "PCA and K-Means analysis", nous commençons par passer notre échantillon dans l'algorithme de réduction de variables (package sklearn). Nous affichons les résultats ainsi que les corrélations entre les deux variables du PCA et les autres, puis nous utilisons deux méthodes pour déterminer le nombre optimal de groupes (clusters) à former. "Inertia" montre la somme des distances au carré entre les points et le centre du cluster le plus proche en fonction du nombre de cluster, et c'est lorsque nous observons un coude dans le graphique que nous reconnaissons le nombre recommandé de groupes à former. La "Silhouette", quant à elle, quantifie à quel point chaque objet est bien assigné à son cluster par rapport aux autres. La meilleur valeur est 1 tandis que la pire est -1. 
Finalement, nous demandons à l'algorithme de nous remontrer les valeurs PCA en indiquant quels groupes il fait alors que nous lui fournissons le nombre de clusters avancé par Inertia et Silhouette. 

Viennent ensuite les analyses graphiques. Dans la méthode du cosinus, nous regardons le cosinus de l'angle entre chaque "veceur-éruption" et si cette valeur est au dessus d'un seuil fixé, l'algorithme (package networx) trace un trait entre les deux éruptions. Nous observons les X plus grands groupes de plus près, X étant le nombre de clusters conseillé par Inertia et Silhouette dans la partie "PCA and K-Means analysis", puis nous optimisons le seuil en regardant le nombre d'éruptions présentes dans les 3 premiers groupes, ainsi que le nombre total d'éruptions reprises dans ces groupes en fonction du seuil. Nous choisissons ensuite la valeur qui maximise la taille des 2e et 3e groupes (sauf exceptions, voir rapport, "Problèmes et exceptions"). 
Nous recommençons tout ce processus en examinant la distance euclidienne entre les vecteurs-éruptions plutôt que le cosinus de l'angle entre eux, à la seule différence que le seuil est maintenant une valeur maximale, et les éruptions sont reliées seulement si la distance entre elles est plus petite que le seuil. 

Le code principal est "Solar_flare_selection", il reprend le plus grand échantillon. 
"Solar_flare_selection_sans_gamma" utilise le même échantillon, mais sans prendre en compte la fluence en gamma. 
"Solar_flare_selection_delta" effectue l'analyse en ajoutant l'indice spectral comme variable à "Solar_flare_selection", tandis que "Solar_flare_selection_radio" y ajoute la durée d'émission de type II. "Solar_flare_selection_complet" observe toutes les variabes en même temps. 

Il y a aussi le code "Associations" qui sert à recenser la fréquence à laquelle les éruptions sont classées dans le même groupe. Nous itérons sur chaque groue de chaque méthode de tri (il y en a 12 : PCA, cos et euc, pour chaque code mentionné ci-dessus sauf "Solar_flare_selection_sans_gamma", car ils étaient quasi-identiques à ceux de "Solar_flare_selection") pour créer une matrice symétrique du nombre de fois que chaque éruption est classée avec chaque autre. Ensuite, nous parcourons cette matrice pour trouver les associations les plus solides. 
Dans un second temps, nous refaisons la même opération, mais avec chaque paire retenue. Les triplets que le code nous fournit sont fiables, mais il y a des doublons. 
Nous recommençons à nouveau pour former des quadruplets, mais les résultats ne semblent pas cohérents, sans doute à cause des marges sur la récurrence autorisées dans la sélection des triplets et quadruplets. 

---> Chaque code peut être exécuté tel quel, il n'y a pas besoin de le modifier pour qu'il soit fonctionnel. 
